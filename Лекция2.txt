Тема 4: Инструментальные средства.
Системы контроля версий

1 Системы контроля версий. Мотивация
При работе над крупным проектом часто случается:
● Несколько версий одного и того же кода:
● Под разные платформы;
● При адаптации продукта под разных заказчиков;
● Несколько программистов правят один и тот же код одновременно;
● Хотим знать кто и зачем сделал то или иное изменение в коде (кто 
виноват?);
● Хотим управлять изменениями (соединять работу нескольких 
программистов или разных версий кода);
● Хотим структурировать код по времени (отслеживать изменения), 
желательно в графическом виде;
● Необходимо автоматизировать какую-то работу:
● Перед созданием новой версии продукта — запустить тесты;
● Перед загрузкой кода от программиста в общий доступ — проверить 
соответствие стандартам кодирования, запустить тесты.
● Ситуация — вы работаете над версией 2.0 вашей «супер-системы», 
заказчик пока что использует 1.0. Версия 2.0 еще совсем сырая (не 
компилируется). Заказчик находит критическую ошибку в версии 1.0.


Распределенные системы позволяют лучше масштабировать процесс разработки.

Системы контроля версий. Git. Основные команды

1. add - Эта команда добавляет файлы или изменения в staging area, готовя их к следующему коммиту.
2. commit - Команда commit создает новую версию проекта, фиксируя те изменения, которые были добавлены в staging area командой add. Каждый коммит имеет уникальный идентификатор (hash) и содержит информацию об авторе, дате и комментарий к изменениям.
3. push - Эта команда передает локальные коммиты на удаленный репозиторий, например, на сервер GitHub или GitLab.
4. fetch - Команда fetch получает изменения из удаленного репозитория, но не интегрирует их в локальный проект. Она просто скачивает изменения и обновляет ссылки на удаленные ветки.
5. checkout - Команда checkout позволяет переключаться между ветками или восстанавливать файлы из конкретного коммита.
6. merge - Эта команда объединяет ветки, позволяя интегрировать изменения из одной ветки в другую. Она помогает разрешать возможные конфликты, возникающие при слиянии.



Системы контроля версий. Git. Конфликты слияния

При слиянии могут возникнуть конфликты, при этом исходный код будет 
дополнен чем-то типа <<<<<<< master … <<<<<<<<< your_branch ……
Перед push надо разрешить конфликт — можно вручную, а можно 
специальными инструментами — meld и аналогами

● git status - определение состояния файлов;
● git log - просмотр истории;
● git fetch - обновить данные;
● git branch информация о ветках, в том числе, текущей.

Gitflow - методология работы с Git, определяет, какие ветки нужно создать и как производить их слияние.


Удаление файлов из git-репозитория.

Лишние файлы:
1. Занимают место — ограничения в Bitbucket -2Гб, GitHub - 1 Гб).
2. Затрудняют восприятие проекта.
3. Уменьшают скорость работы.

Решить проблему можно так:
● Использовать .gitignore;
● Создать новый репозиторий (без мусора);
● Использовать специальные инструменты:
● Git-filter-branch;
● BFG Repo-Cleaner


Удаление файлов из git-репозитория. 
Работа с git-filter-branch
1. Клонировать репозиторий:
 git clone https://bitbucket.org/rrrfer-admin/test_git_filter
 cd test_git_filter
2. Выполнить команду по удалению ненужных файлов:
 git filter-branch --tree-filter 'rm -f images/*.jpg' HEAD
 git filter-branch --tree-filter 'rm -rf folder1’ HEAD
3. Выполнить команду по очистке от мусора:
 git reflog expire --expire=now --all && git gc --prune=now --aggressive
4. Выполнить команду по обновлению историй веток и тегов:
 git push origin --force --all
 git push origin --force –tags
5. Сохранить изменения:
 git push


Удаление файлов из git-репозитория. 
Работа с BFG Repo-Cleaner
0. Установить JRE, скачать bfg.version.jar: https://rtyley.github.io/bfg-repo-cleaner/
1. Клонировать репозиторий:
 git clone --mirror https://bitbucket.org/rrrfer-admin/test_git_filter
 cd test_git_filter
2. Выполнить команду по удалению ненужных файлов:
 java –jar bfg-1.13.0.jar –delete-files ‘*.jpg’ --no-blob-protection
3. Выполнить команду по очистке от мусора:
 git reflog expire --expire=now --all && git gc --prune=now --aggressive
4. Сохранить изменения:
 git push










